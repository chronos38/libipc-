\documentclass[a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{blindtext}
\usepackage{longtable}
\usepackage{color}
\usepackage{listings}

\newenvironment{customindent}[1]
{\begin{list}{}
	{\setlength{\leftmargin}{#1}}
    	\item[]
    }
{\end{list}}

\begin{document}
\thispagestyle{empty}
\begin{center}
\huge
\textbf{Software Spezifikation}\\
\textit{libipc++}
\end{center}

\pagenumbering{Roman}
\cleardoublepage
\tableofcontents
\cleardoublepage

\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Einleitung}
\textit{libipc++} wird als Programmierprojekt im fünften Semester des Bachelor Informatik an der FH Technikum Wien erstellt.

\section{Zweck}
Dieses Dokument soll die technische, funktionale und nicht-funktionale Aspekte des Projekts erläutern. Ebenfalls werden Performance-Kriterien, sowie Fehlerkriterien erläutert. Am Ende soll die \textit{libipc++} den hier definierten Regeln und Anforderungen entsprechen.

\section{Umfang}
Für das Projekt werden als erste Schätzung 400 Stunden benötigt. Was pro Person dann 200 Stunden ausmacht. Wobei ungefähr die Hälfte dieser Zeit für Software-Tests zur Verfügung stehen muss. Ausnahme ist natürlich eine reibungslose Programmierung.

\subsection{Versionierung}
Als Versionierung wird ein Zahlensystem verwendet. Es gibt drei Zahlen in der Versionsnummer, die major number, minor number und patch level. Die Version ist dann wie folgt aufgebaut: $<$major$>$.$<$minor$>$.$<$patch$>$.\newline

\noindent Falls es zu einer Revision eines Patches kommt, dann wird für interne Zwecke eine Revisionsnummer an der Version angehängt, diese sieht dann wie folgt aus: $<$major$>$.$<$minor$>$.$<$patch$>$.$<$revision$>$.

\subsection{Statusberichte}
Am Ende einer jeden Entwicklungswoche, wird ein Statusbericht angefertigt. Dieser Bericht beinhaltet dann die abgeschlossenen Themen der Woche eines jeden einzelnen Entwicklers beziehungsweise die Probleme die der Entwickler hatte.\newline

\noindent Weiters wird eine Statistik mit den Bereits abgeschlossenen Arbeitspaketen und den noch übrigen angezeigt und eine Zeittabelle mit den bereits aufgebrauchten Stunden eines jeden einzelnen Entwicklers angezeigt.

\subsection{Zeiterfassung}
Ein jeder Arbeitsschritt der für das Projekt investiert wurde, wird in der Zeiterfassung protokolliert. Dies dient für spätere Zeitschätzungen, sodass man auf diese Ressourcen zurückgreifen kann.

\subsection{Kanban}
Als Management wird eine abgewandelte Form von Kanban verwendet. Wobei aufgrund der immanenten Studienzeit lokale Änderungen vorgenommen werden können. Diese werden dann im Statusbericht am Ende der Woche protokolliert. Im folgenden werden die Meetings vorgestellt:

\subsubsection{Statusmeeting}
Findet im unterschied zu Kanban nur einmal die Woche statt. Am Ende einer jeden Woche, in diesem Fall Sonntag, wird ein Treffen vereinbart in dem die Fortschritte der Woche oder etwaige Probleme besprochen werden.

\subsubsection{Root Cause Analysis}
Dieses Meeting findet gleich nach dem Statusmeeting statt. Hier werden Probleme genauer analysiert, vor allem dauerhafte Problemen oder Tickets die nicht zu lange in einer Station verweilen.

\subsubsection{Operations Review}
Diese Meeting findet einmal im Monat statt, idealerweise am Ende des Monats nach den Root Cause Analysis. Hier werden die angewendeten Methoden genauer analysiert und gegebenenfalls verbessert. Dieses Meeting macht nur dann Sinn wenn genug Daten für eine Verwertung gesammelt wurden. Falls nicht genug Daten vorhanden sind, dann wird das Meeting um ein Monat verschoben.

\subsubsection{Board}
Als Board dient \href{https://waffle.io/chronos38/libipc-}{waffle.io}.

\subsubsection{Tickettypen}
Alle Tickets die in Kanban verwendet werden, wurden übernommen. Diese sind:\newline
\textbf{Expedite} - Haben hohe Priorität und müssen sofort gemacht werden.\newline
\textbf{Fixed Date} - Haben einen fixen Termin für die Fertigstellung.\newline
\textbf{Vage} - Sind nachrangige Tickets mit geringer Priorität.\newline
\textbf{Standard} - Hat normale Priorität und wird als FIFO (First In First Out) behandelt.

\subsubsection{Expedite}
Diese Tickets dürfen mit Vorrang behandelt werden. Sie zählen nicht zu der Limitierung der einzelnen Spalten und müssen sofort abgearbeitet werden.

\subsubsection{Fixed Date}
Dieses Ticket hat eine normale Priorität bis zur angegebenen Deadline. Falls das Ticket bis zu diesem Zeitpunkt noch nicht fertig ist, dann wird es zu einem \textit{Expedite} konvertiert.

\section{Erläuterungen und Begriffe}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|}
\hline
Kanban & Form von Projektmanagement \\
\hline
SRS & Software requirement specification \\
\hline
MPC & Multi processing \\
\hline
IPC & Interprocess communication \\
\hline
OS & Operating system \\
\hline
API & Application programming interface \\
\hline
FIFO & First In First Out \\
\hline
OOP & Object oriented programming \\
\hline
IDE & Integrated development environment \\
\hline
LVA & Lehrveranstaltung \\
\hline
MSDN & Microsoft Developer Network \\
\hline
MSMQ & Microsoft Message Queues \\
\hline
\end{longtable}
\end{center}

\section{Verweise auf sonstige Ressourcen oder Quellen}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|}
\hline
FH Technikum Wien & \url{http://www.technikum-wien.at/} \\
\hline
SRS & \url{https://de.wikipedia.org/wiki/Software_Requirements_Specification} \\
\hline
IDE & \url{https://de.wikipedia.org/wiki/Integrierte_Entwicklungsumgebung} \\
\hline
Kanban & \url{http://de.wikipedia.org/wiki/Kanban_(Softwareentwicklung)} \\
\hline
Project Repository & \url{https://github.com/chronos38/libipc-} \\
\hline
Statusbericht & \href{https://docs.google.com/document/d/12IZJyU6WJ3upd81pHYRQ8KWd34AJqNXi5WnBbJPOtIQ/edit?usp=sharing}{Google Docs} \\
\hline
Root Cause Analysis & \href{https://docs.google.com/document/d/16PQXzEqp1hANgkXX1qEbKkaIwQ57bTGZWJuKGO_t0wA/edit?usp=sharing}{Google Docs} \\
\hline
Zeiterfassung & \href{https://docs.google.com/spreadsheet/ccc?key=0AuApAQ4FqnCEdHdiWThZX2V5b1BsM2lWYWdWSzZNRVE&usp=sharing}{Google Docs} \\
\hline
Kanban Board & \href{https://waffle.io/chronos38/libipc-}{GitHub - Waffle Kanban Management} \\
\hline
C++ Referenz & \url{http://en.cppreference.com/w/} \\
\hline
Design Pattern & \url{https://de.wikipedia.org/wiki/Entwurfsmuster} \\
\hline
CMake & \url{http://www.cmake.org/} \\
\hline
Boost.Interprocess & \url{http://www.boost.org/doc/libs/1_56_0/doc/html/interprocess.html} \\
\hline
OpenMP & \url{http://openmp.org/wp/} \\
\hline
Beej IPC & \url{http://beej.us/guide/bgipc/} \\
\hline
MSDN & \url{http://msdn.microsoft.com/en-us/default.aspx} \\
\hline
Win32 Processing & \url{http://msdn.microsoft.com/en-us/library/windows/desktop/ms684852\%28v=vs.85\%29.aspx} \\
\hline
Win32 Pipes & \url{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365784\%28v=vs.85\%29.aspx} \\
\hline
MSMQ & \url{http://msdn.microsoft.com/en-us/library/ms711472\%28v=vs.85\%29.aspx} \\
\hline
\end{longtable}
\end{center}

\chapter{Allgemeine Beschreibung}
\textit{libipc++} dient zum Einstatz für Interprozesskommunikation. Der Grund weshalb diese Bibltiothek existieren soll, ist dass es noch keine schöne IPC (Inter process communication) Lösung gibt. Das Ziel dieser Bibliothek ist deshalb eine syntaktische schöne und konsistente API (Application programming interface) für MPC (Multi processing) und IPC zu bieten.\newline

\noindent Die Bibliothek wird auf allen gängigen und modernen OS (Operating system) lauffähig sein. Abhängigkeiten gibt es nur auf OS-Ebene, wodurch keine weiteren Programmbibliotheken notwendig sind.

\section{Produktperspektive}
Als Vergleich soll hier die Boost.Interprocess dienen. Die Boost.Interprocess ist zwar mächtig, jedoch syntaktische nicht sehr elegant und erfordert eine höheres Verständnis für den Endanwender. Im Gegensatz dazu soll \textit{libipc++} eine ähnlich mächtige API anbieten, jedoch eine syntaktisch höherwertige API bieten. Das Ziel ist dass der Endanwender kein tieferes Verständnis für die Anwendung braucht. Der Endanwender soll beispielsweise Memory Mapped Files problemlos verwenden können, ohne jedoch deren Ablauf verstehen zu müssen.\newline

\noindent Auch wenn Boost.Interprocess als Hauptvergleichspunkt dient, werden hier nun alle Vergleiche durchgenommen.

\subsection{Boost.Interprocess}
Das Ziel von Boost.Interprocess ist eine vereinfachte Plattformübergreifende Softwarelösung for MPC und IPC. Es bietet einige Features wie Shared memory oder Memory-mapped files an. Die Bibliothek ist mächtig und sehr stabil und befindet sich nahe am C++ Standard, was schließlich der Grund ist warum die Boost.Interprocess als Referenz ausgewählt wurde.
Eines der Hauptprobleme an Boost.Interprocess ist nicht nur seine schwer zugängliche Syntax, sondern auch der Overhead den diese mitbringt. Ziel von \textit{libipc++} ist es eine ähnlich mächtige API mit geringeren Overhead und einer schöneren Syntax zu realisieren.

\subsection{OpenMP}
Neben Boost.Interprocess hat sich die OpenMP als quasi Standard durchgesetzt. Sie wird von allen großen Herstellern und OS unterstützt. Jedoch versucht OpenMP Parallelität durch den C Präprozessor zu realisieren. Diese Art von Design wird als überholt und veraltet erachtet. Aus diesem Grund wurde OpenMP nicht als Referenz zu diesen Projekt gewählt.

\section{Produktfunktion}
\textit{libipc++} soll wie schon erwähnt eine MPC und IPC bieten, hierzu wird auf Systemressourcen zurückgegriffen. Im folgenden findet sich ein kleiner Überblick über die Funktionalität der Software.

\subsection{Prozess}
Als Grundfunktion was IPC überhaupt erst notwendig macht, ist es einen neuen Prozess innerhalb eines Programms zur Laufzeit zu starten. Diese Funktionalität ist sehr stark vom verwendeten OS abhängig. In diesem wird daher lediglich das allgemeine Konzept eines Kindprozesses innerhalb eines Programms besprochen.\newline

\noindent Wenn ein ausgeführtes Programm einen neuen Prozess zur Laufzeit startet, dann läuft dieser als Kindprozess des ausführenden Prozesses. Der neue erstellte Prozess besitzt dann eine eigene Laufzeitumgebung was bedeutet dass er einen eigenen virtuellen Speicherbereich vom OS zugewiesen bekommt. Das Ziel eines Prozesses ist es jedoch meist eine Berechnung oder Anweisung parallel durchzuführen, was bedeutet dass es zumindest ein relevantes Ergebnis gibt. Da der Prozess jedoch einen eigenen virtuellen Speicherbereich besitzt, muss der Speicheraustausch über andere Mechanismen stattfinden.

\subsection{Pipes}
\blindtext

\subsection{Message Queus}
\blindtext

\subsection{Memory-mapped File}
\blindtext

\subsection{Semaphore}
\blindtext

\subsection{Shared Memory}
\blindtext

\section{Benutzermerkmale}
Da es sich bei der \textit{libipc++} um eine Programmbibliothek handelt, werden vom Endanwender gewisse Kenntnisse vorausgesetzt, im folgenden werden diese kurz beschrieben.

\subsection{C++}
Die Bibliothek wird in \texttt{C++} implementiert, was bedeutet dass der Endanwender zumindest fortgeschrittene Kenntnisse in \texttt{C++} aufweisen sollte. Als Mindestvoraussetzung gilt die Version \texttt{C++11}. Verwendet werden mehrere Sprachkonzepte von \texttt{C++}, darunter auch Templates.

\subsection{Design Patterns}
Ebenfalls wird viel Wert auf Design Patterns gelegt. Wichtig ist dass die Bibliothek leicht erweiterbar und schnell auf Veränderungen reagieren kann. Der Endanwender braucht jedoch nicht unbedingt ein umfangreiches Wissen über Design Patterns, es genügt ein hohes Verständniss über OOP (Object oriented programming).

\section{Einschränkungen}
Da \textit{libipc++} als cross-platform Bibliothek entwickelt wird, muss als das Codetool CMake verwendet werden. Unterstützt werden alle gängigen IDEs (Integrated development environment), sowie UNIX makefile.

\section{Annahme und Abhängigkeiten}
Die \textit{libipc++} wird als Studentenprojekt an der FH Technikum Wien gemacht. Daraus ergibt sich dass für das Projekt nicht der volle Zeitaufwand aufgebracht werden kann wie in einen eigentlichen Softwareprojekt, da es nebenbei noch andere Projekte und LVAs (Lehrveranstaltungen) gibt.

\subsection{Message Queues}
Da die MSMQ (Microsoft Message Queues) Bibliothek wesentlich komplexer ist als zuvor angenommen. Was dazu führen kann dass das Feature unter Win32 nicht vollständig implementiert wird.

\subsection{Betriebssystem}
Entwickelt wird \textit{libipc++} für Windows und Linux, bei Linux speziell ein OpenSUSE Derivat. Der Code wird entsprechend auf diesen beiden OS getestet werden.

\subsection{Nebenberuflich}
Da eine nebenberufliche Tätigkeit von einen Teammitglied nachgegangen wird, kann es zu einigen Verzögerungen innerhalb des Projektflusses kommen. Es wird jedoch darauf geachtet dass diese Tätigkeit keinen zu großen Einfluss auf das Projekt hat.

\subsection{Andere Lehrveranstaltungen}
Das Projekt wird neben anderen LVAs (Lehrveranstaltungen) im Studiengang Bachelor Informatik an der FH Technikum Wien gemacht. Dies kann dann natürlich aufgrund von Überkreuzungen zu einer Verzögerung des Projekts führen.

\section{Aufteilung der Anforderungen}
Anforderungen die nicht zum jetzigen Release miteinbezogen werden können sind
\begin{itemize}
\item Frontend der Bibliothek,
\item Ausbau von NamedPipes,
\item serialisieren von Datenobjekten,
\item umfangreiches Profiling,
\item Benchmark testing und
\item Performancetests im allgemeinen.
\end{itemize}

Diese Features sind für zukünftige Versionen gedacht. Falls es sich jedoch ausgehen sollte diese Features im kommenden Release zu implementieren, dann wird die Spezifikation entsprechen aktualisiert. Als nächstes eine Liste von problematische Features die vielleicht nicht realisiert werden können wenn der tatsächlichen Aufwand höher ist als der geschätzte Aufwand ist.
\begin{itemize}
\item MessageQueues (Win32)
\end{itemize}

\chapter{Spezifische Anforderungen}
Im Gegensatz zum zweiten Kapitel, wo nur allgemeine Anforderungen und Beschreibungen vorgenommen wurden, werden hier nun die Anforderungen im Detail spezifiziert. Beginnend mit den funktionalen Anforderungen die Themen wie die Bibliotheksfunktionen beinhalten zu den nicht-funktionalen Anforderungen die Themen wie
\begin{itemize}
\item Zuverlässigkeit,
\item Benutzbarkeit,
\item Wartbarkeit,
\item Flexibilität,
\item Skalierbarkeit und
\item Sicherheit
\end{itemize}
im Detail beschreiben. Danach werden noch externe APIs und andere verwendete externe Produkte beschrieben. Zum Schluss gibt es noch einen Überblick über die geforderte Performance, den zu erwartenden Overhead und einen Vergleich mit anderen Produkten der selben Kategorie.

\section{Funktionale Anforderungen}
Die \textit{libipc++} teilt sich im wesentlichen in zwei Blöcke ein. Den Plattform-spezifischen Block der dazu dient die OS API als ein einheitliches Interface zu adaptieren. Dieser Block wird als Backend bezeichnet. Und den zweiten Block der dann die abstrahierte OS API zu einer schönen high level API adaptiert. Dieser Block wird als Frontend bezeichnet.\newline

\noindent Die Beschreibung der Win32 Argumente wird in Englisch gehalten, der Grund hierfür ist die ebenfalls englische Ausführung auf der MSDN (Microsoft Developer Network).

\subsection{Backend}
Dadurch dass die \textit{libipc++} auf unterschiedlichen OS funktionieren soll, diese jedoch kein einheitliches System von IPC besitzen, ist es notwendig die zur Verfügung stehende OS API zu einer einheitlichen abstrakten API zusammenzufassen. Im nachfolgenden werden die OS spezifischen Funktionen genauer erläutert. Angefangen wird mit der Erzeugung eines neuen Prozesses. Es sei noch angemerkt dass immer zuerst die Win32 Funktion erläutert wird, danach die UNIX Funktion. Der Grund ist dass die UNIX Funktionen meist wohlbekannt sind, jedoch die Win32 Funktionen dadurch dass sie seltener verwendet werden eher unbekannt sind.\newline

\noindent Sämtliche hier präsentierten Funktionen können auch selber in der entsprechenden Dokumentation nachgelesen werden. Der Verweis befindet sich unter der Sektion externe Ressourcen.

\subsubsection{Prozess}
Ein Prozess wird im wesentlichen durch den Aufruf einer einzelnen Funktion erzeugt.

\lstset{language=[Visual]C++}
\begin{lstlisting}[caption={CreateProcess},frame=single]
BOOL WINAPI CreateProcess(
  _In_opt_     LPCTSTR lpApplicationName,
  _Inout_opt_  LPTSTR lpCommandLine,
  _In_opt_     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  _In_opt_     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  _In_         BOOL bInheritHandles,
  _In_         DWORD dwCreationFlags,
  _In_opt_     LPVOID lpEnvironment,
  _In_opt_     LPCTSTR lpCurrentDirectory,
  _In_         LPSTARTUPINFO lpStartupInfo,
  _Out_        LPPROCESS_INFORMATION lpProcessInformation
);
\end{lstlisting}

\noindent \textit{lpApplicationName} [in, optional]
\begin{customindent}{1cm}
    The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.

    The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.

    The \textit{lpApplicationName} parameter can be \textbf{NULL}. In that case, the module name must be the first white space–delimited token in the \textit{lpCommandLine} string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\textbackslash program files\textbackslash sub dir\textbackslash program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:

        \textbf{c:\textbackslash program.exe} files\textbackslash sub dir\textbackslash program name\newline
        \textbf{c:\textbackslash program files\textbackslash sub.exe} dir\textbackslash program name\newline
        \textbf{c:\textbackslash program files\textbackslash sub dir\textbackslash program.exe} name\newline
        \textbf{c:\textbackslash program files\textbackslash sub dir\textbackslash program name.exe}\newline

    If the executable module is a 16-bit application, \textit{lpApplicationName} should be \textbf{NULL}, and the string pointed to by \textit{lpCommandLine} should specify the executable module as well as its arguments.

    To run a batch file, you must start the command interpreter; set \textit{lpApplicationName} to cmd.exe and set \textit{lpCommandLine} to the following arguments: /c plus the name of the batch file.
\end{customindent}

\noindent \textit{lpCommandLine} [in, out, optional]
\begin{customindent}{1cm}
    The command line to be executed. The maximum length of this string is 32,768 characters, including the Unicode terminating null character. If \textit{lpApplicationName} is \textbf{NULL}, the module name portion of \textit{lpCommandLine} is limited to \textbf{MAX\_PATH} characters.

    The Unicode version of this function, CreateProcessW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.

    The \textit{lpCommandLine} parameter can be \textbf{NULL}. In that case, the function uses the string pointed to by \textit{lpApplicationName} as the command line.

    If both \textit{lpApplicationName} and \textit{lpCommandLine} are non-\textbf{NULL}, the null-terminated string pointed to by \textit{lpApplicationName} specifies the module to execute, and the null-terminated string pointed to by \textit{lpCommandLine} specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.

    If \textit{lpApplicationName} is \textbf{NULL}, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the \textit{lpApplicationName} parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:

\begin{enumerate}
        \item The directory from which the application loaded.
        \item The current directory for the parent process.
        \item The 32-bit Windows system directory. Use the GetSystemDirectory function to get the path of this directory.
        \item The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.
        \item The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.
        \item The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the App Paths registry key. To include this per-application path in the search sequence, use the ShellExecute function.
\end{enumerate}

    The system adds a terminating null character to the command-line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.
\end{customindent}

\noindent \textit{lpProcessAttributes} [in, optional]
\begin{customindent}{1cm}
    A pointer to a \textbf{SECURITY\_ATTRIBUTES} structure that determines whether the returned handle to the new process object can be inherited by child processes. If \textit{lpProcessAttributes} is \textbf{NULL}, the handle cannot be inherited.

    The \textit{lpSecurityDescriptor} member of the structure specifies a security descriptor for the new process. If \textit{lpProcessAttributes} is \textbf{NULL} or \textit{lpSecurityDescriptor} is \textbf{NULL}, the process gets a default security descriptor. The ACLs in the default security descriptor for a process come from the primary token of the creator.

    \textbf{Windows XP:}  The ACLs in the default security descriptor for a process come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.
\end{customindent}

\noindent \textit{lpThreadAttributes} [in, optional]
\begin{customindent}{1cm}
    A pointer to a \textbf{SECURITY\_ATTRIBUTES} structure that determines whether the returned handle to the new thread object can be inherited by child processes. If \textit{lpThreadAttributes} is \textbf{NULL}, the handle cannot be inherited.

    The \textit{lpSecurityDescriptor} member of the structure specifies a security descriptor for the main thread. If \textit{lpThreadAttributes} is \textbf{NULL} or \textit{lpSecurityDescriptor} is \textbf{NULL}, the thread gets a default security descriptor. The ACLs in the default security descriptor for a thread come from the process token.

    \textbf{Windows XP:}  The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.
\end{customindent}

\newpage
\noindent \textit{bInheritHandles} [in]
\begin{customindent}{1cm}
	If this parameter TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
\end{customindent}

\noindent \textit{dwCreationFlags} [in]
\begin{customindent}{1cm}
    The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.

    This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see \textbf{GetPriorityClass}. If none of the priority class flags is specified, the priority class defaults to \textbf{NORMAL\_PRIORITY\_CLASS} unless the priority class of the creating process is \newline\textbf{IDLE\_PRIORITY\_CLASS} or \newline\textbf{BELOW\_NORMAL\_PRIORITY\_CLASS}. In this case, the child process receives the default priority class of the calling process.
\end{customindent}

\noindent \textit{lpEnvironment} [in, optional]
\begin{customindent}{1cm}
    A pointer to the environment block for the new process. If this parameter is \textbf{NULL}, the new process uses the environment of the calling process.

    An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:

    name=value\textbackslash 0

    Because the equal sign is used as a separator, it must not be used in the name of an environment variable.

    An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that \textit{dwCreationFlags} includes \newline\textbf{CREATE\_UNICODE\_ENVIRONMENT}. If this parameter is \textbf{NULL} and the environment block of the parent process contains Unicode characters, you must also ensure that \textit{dwCreationFlags} includes \newline\textbf{CREATE\_UNICODE\_ENVIRONMENT}.

    The ANSI version of this function, \textit{CreateProcessA} fails if the total size of the environment block for the process exceeds 32,767 characters.

    Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
\end{customindent}

\noindent \textit{lpCurrentDirectory} [in, optional]
\begin{customindent}{1cm}
    The full path to the current directory for the process. The string can also specify a UNC path.

    If this parameter is \textbf{NULL}, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
\end{customindent}

\noindent \textit{lpStartupInfo} [in]
\begin{customindent}{1cm}
    A pointer to a \textbf{STARTUPINFO} or \textbf{STARTUPINFOEX} structure.

    To set extended attributes, use a \textbf{STARTUPINFOEX} structure and specify \textbf{EXTENDED\_STARTUPINFO\_PRESENT} in the \textit{dwCreationFlags} parameter.

    Handles in \textbf{STARTUPINFO} or \textbf{STARTUPINFOEX} must be closed with \textbf{CloseHandle} when they are no longer needed.

    Important  The caller is responsible for ensuring that the standard handle fields in \textbf{STARTUPINFO} contain valid handle values. These fields are copied unchanged to the child process without validation, even when the \textit{dwFlags} member specifies \textbf{STARTF\_USESTDHANDLES}. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
\end{customindent}

\noindent \textit{lpProcessInformation} [out]
\begin{customindent}{1cm}
    A pointer to a \textbf{PROCESS\_INFORMATION} structure that receives identification information about the new process.

    Handles in \textbf{PROCESS\_INFORMATION} must be closed with CloseHandle when they are no longer needed.
\end{customindent}

\paragraph{Return value}
\begin{customindent}{1cm}
	If the function succeeds, the return value is nonzero.

	If the function fails, the return value is zero. To get extended error information, call \textbf{GetLastError}.

	Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call \newline\textbf{GetExitCodeProcess}.
\end{customindent}

\noindent Die weiteren Funktionen für Prozessmanagement können auf der MSDN nachgelesen werden. Als nächstes folgt das UNIX Pendant.

\lstset{language=[GNU]C++}
\begin{lstlisting}[caption={fork},frame=single]
pid_t fork(void);
\end{lstlisting}

\noindent Auch hier können die restlichen Prozessmanagementfunktionen in der offiziellen Dokumentation nachgelesen werden. Als nächstes wird nun die zu adaptierende Klasse beschrieben.

\lstset{language=C++,breaklines=true}
\begin{lstlisting}[caption={class Process},frame=single]
class IPC_API Process : public ReferenceType {
  public:
    Process();
    Process(Process&& process);
    virtual ~Process();
    
    int ExitCode() const;
    ProcessHandle Handle() const;
    void Kill() const;
    bool Valid() const;
    void Wait() const;
    
    template<typename Rep, typename Period>
    bool WaitFor(const std::chrono::duration<Rep, Period>& timeoutDuration) const;
    
    template <typename Clock, typename Duration>
    bool WaitUntil(const std::chrono::time_point<Clock, Duration>& timoutTime) const;
    
    Process& operator=(Process&& process);
    bool operator==(const Process& process) const;
    bool operator!=(const Process& process) const;
    
  private:
};
\end{lstlisting}

\subsection{Frontend}
Das Frontend stellt die high level API dar. Das Frontend ist anders als das Backend nicht von der OS API abhängig, sondern von der Abstrahierten API die unter Backend beschrieben wurde.\newline

\noindent \textbf{Dieses Feature wird erst im nächsten Release implementiert.}

\section{Nicht-Funktionale Anforderungen}
\subsection{Versionierung}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|}
\hline
0.1 & Abstrakte API \\
\hline
0.2 & Process \\
\hline
0.3 & AnonymousPipe \\
\hline
0.4 & NamedPipe \\
\hline 
0.5 & MessageQueue \\
\hline
0.6 & Semaphore \\
\hline
0.7 & MemoryMap, SharedMemory \\ 
\hline
0.8 & FileLocking \\
\hline
0.9 & Profiling Windows und Linux\\
\hline
1.0 & Release \\
\hline
\end{longtable}
\end{center}
Die erste Version bietet noch keine Features an. Es wird die API von \textit{libipc++} implementiert und auf Konsistenz getestet. Dabei werden alle notwendigen und definierten Klassen beschrieben, deren Methoden und Felder dokumentiert sowie Utility-Funktionalität beschrieben. Es ist wichtig dass das Design eine eigene Version erhält, da dadurch erst mit der Implementierung begonnen werden kann wenn das Design voll funktionsfähig und getestet ist. Folgende Klassen müssen definiert und getestet sein bevor die Version abgeschlossen wird.\newline

\noindent Jede Version nach der Version 0.1 implementiert dann die entsprechende Klasse für die unterstützten Plattformen. Eine Klasse gilt erst dann als fertig wenn
\begin{itemize}
\item sie vollständig implementiert ist,
\item sie ausreichend getestet ist,
\item sie umfangreich dokumentiert ist
\item und best practice als auch Beispielcode für jede Methode existiert.
\end{itemize}

\noindent Eine Ausnahme stellt hier die Version 0.9 dar. Diese Version dient lediglich dazu den bereits existierenden Code zu optimieren. Primär für die Geschwindigkeit. Wie bereits erwähnt, kann es zu Verzögerungen bei dieser Version kommen.

\section{Externe Schnittstellen}
\blindtext

\section{Anforderungen an Performance}
\blindtext

\section{Qualitätsanforderungen}
\blindtext


\end{document}
