\documentclass[a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{blindtext}
\usepackage{longtable}
\usepackage{color}
\usepackage{listings}
\usepackage{acronym}

\newenvironment{customindent}[1]
{\begin{list}{}
	{\setlength{\leftmargin}{#1}}
    	\item[]
    }
{\end{list}}

\begin{document}
\thispagestyle{empty}
\begin{center}
\huge
\textbf{Software Spezifikation}\\
\textit{libipc++}
\end{center}

\pagenumbering{Roman}
\cleardoublepage
\tableofcontents
\cleardoublepage

\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Einleitung}
\textit{libipc++} wird als Programmierprojekt im fünften Semester des Bachelor Informatik an der FH Technikum Wien erstellt.

\section{Zweck}
Dieses Dokument soll die technische, funktionale und nicht-funktionale Aspekte des Projekts erläutern. Ebenfalls werden Performance-Kriterien, sowie Fehlerkriterien erläutert. Am Ende soll die \textit{libipc++} den hier definierten Regeln und Anforderungen entsprechen.

\section{Umfang}
Für das Projekt werden als erste Schätzung 400 Stunden benötigt. Was pro Person dann 200 Stunden ausmacht. Wobei ungefähr die Hälfte dieser Zeit für Software-Tests zur Verfügung stehen muss. Ausnahme ist natürlich eine reibungslose Programmierung.

\subsection{Versionierung}
Als Versionierung wird ein Zahlensystem verwendet. Es gibt drei Zahlen in der Versionsnummer, die major number, minor number und patch level. Die Version ist dann wie folgt aufgebaut: $<$major$>$.$<$minor$>$.$<$patch$>$.\newline

\noindent Falls es zu einer Revision eines Patches kommt, dann wird für interne Zwecke eine Revisionsnummer an der Version angehängt, diese sieht dann wie folgt aus: $<$major$>$.$<$minor$>$.$<$patch$>$.$<$revision$>$.

\subsection{Statusberichte}
Am Ende einer jeden Entwicklungswoche, wird ein Statusbericht angefertigt. Dieser Bericht beinhaltet dann die abgeschlossenen Themen der Woche eines jeden einzelnen Entwicklers beziehungsweise die Probleme die der Entwickler hatte.\newline

\noindent Weiters wird eine Statistik mit den Bereits abgeschlossenen Arbeitspaketen und den noch übrigen angezeigt und eine Zeittabelle mit den bereits aufgebrauchten Stunden eines jeden einzelnen Entwicklers angezeigt.

\subsection{Zeiterfassung}
Ein jeder Arbeitsschritt der für das Projekt investiert wurde, wird in der Zeiterfassung protokolliert. Dies dient für spätere Zeitschätzungen, sodass man auf diese Ressourcen zurückgreifen kann.

\subsection{Kanban}
Als Management wird eine abgewandelte Form von Kanban verwendet. Wobei aufgrund der immanenten Studienzeit lokale Änderungen vorgenommen werden können. Diese werden dann im Statusbericht am Ende der Woche protokolliert. Im folgenden werden die Meetings vorgestellt:

\subsubsection{Statusmeeting}
Findet im unterschied zu Kanban nur einmal die Woche statt. Am Ende einer jeden Woche, in diesem Fall Sonntag, wird ein Treffen vereinbart in dem die Fortschritte der Woche oder etwaige Probleme besprochen werden.

\subsubsection{Root Cause Analysis}
Dieses Meeting findet gleich nach dem Statusmeeting statt. Hier werden Probleme genauer analysiert, vor allem dauerhafte Problemen oder Tickets die nicht zu lange in einer Station verweilen.

\subsubsection{Operations Review}
Diese Meeting findet einmal im Monat statt, idealerweise am Ende des Monats nach den Root Cause Analysis. Hier werden die angewendeten Methoden genauer analysiert und gegebenenfalls verbessert. Dieses Meeting macht nur dann Sinn wenn genug Daten für eine Verwertung gesammelt wurden. Falls nicht genug Daten vorhanden sind, dann wird das Meeting um ein Monat verschoben.

\subsubsection{Board}
Als Board dient \href{https://waffle.io/chronos38/libipc-}{waffle.io}.

\subsubsection{Tickettypen}
Alle Tickets die in Kanban verwendet werden, wurden übernommen. Diese sind:\newline
\textbf{Expedite} - Haben hohe Priorität und müssen sofort gemacht werden.\newline
\textbf{Fixed Date} - Haben einen fixen Termin für die Fertigstellung.\newline
\textbf{Vage} - Sind nachrangige Tickets mit geringer Priorität.\newline
\textbf{Standard} - Hat normale Priorität und wird als \ac{fifo} (First In First Out) behandelt.

\subsubsection{Expedite}
Diese Tickets dürfen mit Vorrang behandelt werden. Sie zählen nicht zu der Limitierung der einzelnen Spalten und müssen sofort abgearbeitet werden.

\subsubsection{Fixed Date}
Dieses Ticket hat eine normale Priorität bis zur angegebenen Deadline. Falls das Ticket bis zu diesem Zeitpunkt noch nicht fertig ist, dann wird es zu einem \textit{Expedite} konvertiert.

\section{Erläuterungen und Begriffe}
\begin{acronym}[XXXXX]
	\acro{os}[OS]{Betriebssystem}
	\acro{srs}[SRS]{Software Requirement Specification}
	\acro{mpc}[MPC]{Multi processing}
	\acro{ipc}[IPC]{Interprocess communication}
	\acro{api}[API]{Application programming interface}
	\acro{fifo}[FIFO]{first in first out}
	\acro{oop}[OOP]{Object oriented programming}
	\acro{ide}[IDE]{Integragted development enviroment}
	\acro{lva}[LVA]{Lehrveranstaltung}
	\acro{msdn}[MSDN]{Microsoft Developer Network}
	\acro{msmq}[MSMQ]{Microsoft Message Queues}
	\acro{ram}[RAM]{Random Access Memory}
\end{acronym}

\section{Verweise auf sonstige Ressourcen oder Quellen}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|}
\hline
FH Technikum Wien & \url{http://www.technikum-wien.at/} \\
\hline
\ac{srs} & \url{https://de.wikipedia.org/wiki/Software_Requirements_Specification} \\
\hline
\ac{ide} & \url{https://de.wikipedia.org/wiki/Integrierte_Entwicklungsumgebung} \\
\hline
Kanban & \url{http://de.wikipedia.org/wiki/Kanban_(Softwareentwicklung)} \\
\hline
Project Repository & \url{https://github.com/chronos38/libipc-} \\
\hline
Statusbericht & \href{https://docs.google.com/document/d/12IZJyU6WJ3upd81pHYRQ8KWd34AJqNXi5WnBbJPOtIQ/edit?usp=sharing}{Google Docs} \\
\hline
Root Cause Analysis & \href{https://docs.google.com/document/d/16PQXzEqp1hANgkXX1qEbKkaIwQ57bTGZWJuKGO_t0wA/edit?usp=sharing}{Google Docs} \\
\hline
Zeiterfassung & \href{https://docs.google.com/spreadsheet/ccc?key=0AuApAQ4FqnCEdHdiWThZX2V5b1BsM2lWYWdWSzZNRVE&usp=sharing}{Google Docs} \\
\hline
Kanban Board & \href{https://waffle.io/chronos38/libipc-}{GitHub - Waffle Kanban Management} \\
\hline
C++ Referenz & \url{http://en.cppreference.com/w/} \\
\hline
Design Pattern & \url{https://de.wikipedia.org/wiki/Entwurfsmuster} \\
\hline
CMake & \url{http://www.cmake.org/} \\
\hline
Boost.Interprocess & \url{http://www.boost.org/doc/libs/1_56_0/doc/html/interprocess.html} \\
\hline
OpenMP & \url{http://openmp.org/wp/} \\
\hline
Beej IPC & \url{http://beej.us/guide/bgipc/} \\
\hline
MSDN & \url{http://msdn.microsoft.com/en-us/default.aspx} \\
\hline
Win32 Processing & \url{http://msdn.microsoft.com/en-us/library/windows/desktop/ms684841\%28v=vs.85\%29.aspx} \\
\hline
Win32 Pipes & \url{http://msdn.microsoft.com/en-us/library/windows/desktop/aa365784\%28v=vs.85\%29.aspx} \\
\hline
MSMQ & \url{http://msdn.microsoft.com/en-us/library/ms711472\%28v=vs.85\%29.aspx} \\
\hline
Win32 File Mapping und Shared Memory & \url{http://msdn.microsoft.com/en-us/library/windows/desktop/aa366556\%28v=vs.85\%29.aspx} \\
\hline
Google Test & \url{https://code.google.com/p/googletest/} \\
\hline
\end{longtable}
\end{center}

\chapter{Allgemeine Beschreibung}
\textit{libipc++} dient zum Einstatz für Interprozesskommunikation. Der Grund weshalb diese Bibltiothek existieren soll, ist dass es noch keine schöne \ac{ipc} Lösung gibt. Das Ziel dieser Bibliothek ist deshalb eine syntaktische schöne und konsistente \ac{api} für \ac{mpc} und \ac{ipc} zu bieten.\newline

\noindent Die Bibliothek wird auf allen gängigen und modernen \ac{os} lauffähig sein. Abhängigkeiten gibt es nur auf \ac{os}-Ebene, wodurch keine weiteren Programmbibliotheken notwendig sind.

\section{Produktperspektive}
Als Vergleich soll hier die Boost.Interprocess dienen. Die Boost.Interprocess ist zwar mächtig, jedoch syntaktische nicht sehr elegant und erfordert eine höheres Verständnis für den Endanwender. Im Gegensatz dazu soll \textit{libipc++} eine ähnlich mächtige \ac{api} anbieten, jedoch eine syntaktisch höherwertige \ac{api} bieten. Das Ziel ist dass der Endanwender kein tieferes Verständnis für die Anwendung braucht. Der Endanwender soll beispielsweise Memory Mapped Files problemlos verwenden können, ohne jedoch deren Ablauf verstehen zu müssen.\newline

\noindent Auch wenn Boost.Interprocess als Hauptvergleichspunkt dient, werden hier nun alle Vergleiche durchgenommen.

\subsection{Boost.Interprocess}
Das Ziel von Boost.Interprocess ist eine vereinfachte Plattformübergreifende Softwarelösung for \ac{mpc} und \ac{ipc}. Es bietet einige Features wie Shared memory oder Memory-mapped files an. Die Bibliothek ist mächtig und sehr stabil und befindet sich nahe am C++ Standard, was schließlich der Grund ist warum die Boost.Interprocess als Referenz ausgewählt wurde.
Eines der Hauptprobleme an Boost.Interprocess ist nicht nur seine schwer zugängliche Syntax, sondern auch der Overhead den diese mitbringt. Ziel von \textit{libipc++} ist es eine ähnlich mächtige \ac{api} mit geringeren Overhead und einer schöneren Syntax zu realisieren.

\subsection{OpenMP}
Neben Boost.Interprocess hat sich die OpenMP als quasi Standard durchgesetzt. Sie wird von allen großen Herstellern und \ac{os} unterstützt. Jedoch versucht OpenMP Parallelität durch den C Präprozessor zu realisieren. Diese Art von Design wird als überholt und veraltet erachtet. Aus diesem Grund wurde OpenMP nicht als Referenz zu diesen Projekt gewählt.

\section{Produktfunktion}
\textit{libipc++} soll wie schon erwähnt eine \ac{mpc} und \ac{ipc} bieten, hierzu wird auf Systemressourcen zurückgegriffen. Im folgenden findet sich ein kleiner Überblick über die Funktionalität der Software.

\subsection{Prozess}
Als Grundfunktion was \ac{ipc} überhaupt erst notwendig macht, ist es einen neuen Prozess innerhalb eines Programms zur Laufzeit zu starten. Diese Funktionalität ist sehr stark vom verwendeten \ac{os} abhängig. In diesem wird daher lediglich das allgemeine Konzept eines Kindprozesses innerhalb eines Programms besprochen.\newline

\noindent Wenn ein ausgeführtes Programm einen neuen Prozess zur Laufzeit startet, dann läuft dieser als Kindprozess des ausführenden Prozesses. Der neue erstellte Prozess besitzt dann eine eigene Laufzeitumgebung was bedeutet dass er einen eigenen virtuellen Speicherbereich vom \ac{os} zugewiesen bekommt. Das Ziel eines Prozesses ist es jedoch meist eine Berechnung oder Anweisung parallel durchzuführen, was bedeutet dass es zumindest ein relevantes Ergebnis gibt. Da der Prozess jedoch einen eigenen virtuellen Speicherbereich besitzt, muss der Speicheraustausch über andere Mechanismen stattfinden.

\subsection{Pipes}
Eine weitverbreitete Variante der Kommunikation sind Pipes, welche durch Unix populär wurden und inzwischen von den meisten Betriebssystemen unterstützt werden. Pipes übertragen sequentiell einzelne Bytes. Jedem Prozess sind immer zwei Datenströme zugeordnet, einer für die Ausgabe und einer für die Eingabe. Ein Ausgabestrom eines Prozesses kann anschließend direkt mit dem Eingabestrom eines anderen Prozesses verbunden werden. \newline
Eine Erweiterung dieses Konzeptes stellen \textbf{Named Pipes} dar: Diese sind nicht einem Prozess fest zugeordnet, sondern können genau wie Dateien geschrieben und gelesen werden. Sie existieren als Objekte im Dateisystem mit einem Namen, und bieten so eine sehr flexible Schnittstelle für die Kommunikation mit einem Prozess.

\subsection{Message Queues}
Message Queues sind wesentlich weniger Verbreitet als Pipes und erlauben es Nachrichten in einzelnen Paketen zu versenden. Diese Kommunikationsform hat den Vorteil dass Nachrichten eine Priorität zugewiesen werden kann, dies erlaubt es bestimmte Nachrichten vor anderen aus dem Queue abzurufen.

\subsection{Memory-mapped File}
Memory-mapped Files erlauben es eine Datei direkt in den Speicher zu kopieren. Besonders bei sehr großen Dateien kann sich dies positiv auf die I/O Performance auswirken.

\subsection{Semaphore}
Semaphoren ermöglichen den Zugriff auf Shared Memory, Dateien oder andere Ressourcen zu kontrollieren. 

\subsection{File Locking}
File Locking ist eine vereinfachte Variante der Zugriffskontrolle speziell für Dateien.


\subsection{Shared Memory}
Shared Memory erlaubt mehreren Prozessen Zugriff auf den selben Speicherbereich. Bei der Verwendung von Shared Memory ist zu beachten dass es zu Concurrency Problemen kommen kann. Daher ist die Verwendung einer Semaphore zur Zugriffskontrolle empfohlen.

\section{Benutzermerkmale}
Da es sich bei der \textit{libipc++} um eine Programmbibliothek handelt, werden vom Endanwender gewisse Kenntnisse vorausgesetzt, im folgenden werden diese kurz beschrieben.

\subsection{C++}
Die Bibliothek wird in \texttt{C++} implementiert, was bedeutet dass der Endanwender zumindest fortgeschrittene Kenntnisse in \texttt{C++} aufweisen sollte. Als Mindestvoraussetzung gilt die Version \texttt{C++11}. Verwendet werden mehrere Sprachkonzepte von \texttt{C++}, darunter auch Templates.

\subsection{Design Patterns}
Ebenfalls wird viel Wert auf Design Patterns gelegt. Wichtig ist dass die Bibliothek leicht erweiterbar und schnell auf Veränderungen reagieren kann. Der Endanwender braucht jedoch nicht unbedingt ein umfangreiches Wissen über Design Patterns, es genügt ein hohes Verständniss über \ac{oop}.

\section{Einschränkungen}
Da \textit{libipc++} als cross-platform Bibliothek entwickelt wird, muss als das Codetool CMake verwendet werden. Unterstützt werden alle gängigen \ac{ide}, sowie UNIX makefile.

\section{Annahme und Abhängigkeiten}
Die \textit{libipc++} wird als Studentenprojekt an der FH Technikum Wien gemacht. Daraus ergibt sich dass für das Projekt nicht der volle Zeitaufwand aufgebracht werden kann wie in einen eigentlichen Softwareprojekt, da es nebenbei noch andere Projekte und \ac{lva} gibt.

\subsection{Message Queues}
Da die \ac{msmq} Bibliothek wesentlich komplexer ist als zuvor angenommen. Was dazu führen kann dass das Feature unter Win32 nicht vollständig implementiert wird.

\subsection{Betriebssystem}
Entwickelt wird \textit{libipc++} für Windows und Linux, bei Linux speziell ein OpenSUSE Derivat. Der Code wird entsprechend auf diesen beiden \ac{os} getestet werden.

\subsection{Nebenberuflich}
Da eine nebenberufliche Tätigkeit von einen Teammitglied nachgegangen wird, kann es zu einigen Verzögerungen innerhalb des Projektflusses kommen. Es wird jedoch darauf geachtet dass diese Tätigkeit keinen zu großen Einfluss auf das Projekt hat.

\subsection{Andere Lehrveranstaltungen}
Das Projekt wird neben anderen \ac{lva}s im Studiengang Bachelor Informatik an der FH Technikum Wien gemacht. Dies kann dann natürlich aufgrund von Überkreuzungen zu einer Verzögerung des Projekts führen.

\section{Aufteilung der Anforderungen}
Anforderungen die nicht zum jetzigen Release miteinbezogen werden können sind
\begin{itemize}
\item Frontend der Bibliothek,
\item Ausbau von NamedPipes,
\item serialisieren von Datenobjekten,
\item umfangreiches Profiling,
\item Benchmark testing und
\item Performancetests im allgemeinen.
\end{itemize}

Diese Features sind für zukünftige Versionen gedacht. Falls es sich jedoch ausgehen sollte diese Features im kommenden Release zu implementieren, wird die Spezifikation entsprechen aktualisiert. Als nächstes eine Liste von problematische Features die vielleicht nicht realisiert werden können wenn der tatsächlichen Aufwand höher ist als der geschätzte ist.
\begin{itemize}
\item MessageQueues (Win32)
\end{itemize}

\chapter{Spezifische Anforderungen}
Im Gegensatz zum zweiten Kapitel, wo nur allgemeine Anforderungen und Beschreibungen vorgenommen wurden, werden hier nun die Anforderungen im Detail spezifiziert. Beginnend mit den funktionalen Anforderungen die Themen wie die Bibliotheksfunktionen beinhalten zu den nicht-funktionalen Anforderungen die Themen wie
\begin{itemize}
\item Zuverlässigkeit,
\item Benutzbarkeit,
\item Wartbarkeit,
\item Flexibilität,
\item Skalierbarkeit und
\item Sicherheit
\end{itemize}
im Detail beschreiben. Danach werden noch externe \ac{api}s und andere verwendete externe Produkte beschrieben. Zum Schluss gibt es noch einen Überblick über die geforderte Performance, den zu erwartenden Overhead und einen Vergleich mit anderen Produkten der selben Kategorie.

\section{Funktionale Anforderungen}
Die \textit{libipc++} teilt sich im wesentlichen in zwei Blöcke ein. Den Plattform-spezifischen Block der dazu dient die \ac{os} \ac{api} als ein einheitliches Interface zu adaptieren. Dieser Block wird als Backend bezeichnet. Und den zweiten Block der dann die abstrahierte \ac{os} \ac{api} zu einer schönen high level \ac{api} adaptiert. Dieser Block wird als Frontend bezeichnet.\newline

\noindent Die Beschreibung der Win32 Argumente wird in Englisch gehalten, der Grund hierfür ist die ebenfalls englische Ausführung auf der MSDN (Microsoft Developer Network).

\subsection{Backend}
Dadurch dass die \textit{libipc++} auf unterschiedlichen \ac{os} funktionieren soll, diese jedoch kein einheitliches System von \ac{ipc} besitzen, ist es notwendig die zur Verfügung stehende \ac{os} \ac{api} zu einer einheitlichen abstrakten \ac{api} zusammenzufassen. Im nachfolgenden werden die \ac{os} spezifischen Funktionen genauer erläutert. Angefangen wird mit der Erzeugung eines neuen Prozesses. Es sei noch angemerkt dass immer zuerst die Win32 Funktion erläutert wird, danach die UNIX Funktion. Der Grund ist dass die UNIX Funktionen meist wohlbekannt sind, jedoch die Win32 Funktionen, dadurch dass sie seltener verwendet werden, eher unbekannt sind.\newline

\noindent Sämtliche hier präsentierten Funktionen können auch selber in der entsprechenden Dokumentation nachgelesen werden. Der Verweis befindet sich unter der Sektion externe Ressourcen.

\subsubsection{Prozess}
\lstset{language=C++,breaklines=true}
\begin{lstlisting}[caption={class Process},frame=single]
class IPC_API Process : public ReferenceType {
  public:
    Process();
    Process(Process&& process);
    virtual ~Process();
    
    int ExitCode() const;
    ProcessHandle Handle() const;
    void Kill() const;
    bool Valid() const;
    void Wait() const;
    
    template<typename Rep, typename Period>
    bool WaitFor(const std::chrono::duration<Rep, Period>& timeoutDuration) const;
    
    template <typename Clock, typename Duration>
    bool WaitUntil(const std::chrono::time_point<Clock, Duration>& timoutTime) const;
    
    Process& operator=(Process&& process);
    bool operator==(const Process& process) const;
    bool operator!=(const Process& process) const;
    
  private:
};
\end{lstlisting}

\subsection{Frontend}
Das Frontend stellt die high level \ac{api} dar. Das Frontend ist anders als das Backend nicht von der \ac{os} \ac{api} abhängig, sondern von der Abstrahierten \ac{api} die unter Backend beschrieben wurde.\newline

\noindent \textbf{Dieses Feature wird erst im nächsten Release implementiert.}

\section{Nicht-Funktionale Anforderungen}
\subsection{Versionierung}
\begin{center}
\begin{longtable}{|p{3cm}|p{8cm}|}
\hline
0.1 & Abstrakte \ac{api} \\
\hline
0.2 & Process \\
\hline
0.3 & AnonymousPipe \\
\hline
0.4 & NamedPipe \\
\hline 
0.5 & MessageQueue \\
\hline
0.6 & Semaphore \\
\hline
0.7 & MemoryMap, SharedMemory \\ 
\hline
0.8 & FileLocking \\
\hline
0.9 & Profiling Windows und Linux\\
\hline
1.0 & Release \\
\hline
\end{longtable}
\end{center}
Die erste Version bietet noch keine Features an. Es wird die \ac{api} von \textit{libipc++} implementiert und auf Konsistenz getestet. Dabei werden alle notwendigen und definierten Klassen beschrieben, deren Methoden und Felder dokumentiert sowie Utility-Funktionalität beschrieben. Es ist wichtig dass das Design eine eigene Version erhält, da dadurch erst mit der Implementierung begonnen werden kann wenn das Design voll funktionsfähig und getestet ist. Folgende Klassen müssen definiert und getestet sein bevor die Version abgeschlossen wird.\newline

\noindent Jede Version nach der Version 0.1 implementiert dann die entsprechende Klasse für die unterstützten Plattformen. Eine Klasse gilt erst als fertig wenn
\begin{itemize}
\item sie vollständig implementiert ist,
\item sie ausreichend getestet ist,
\item sie umfangreich dokumentiert ist
\item und best practice als auch Beispielcode für jede Methode existiert.
\end{itemize}

\noindent Eine Ausnahme stellt hier die Version 0.9 dar. Diese Version dient lediglich dazu den bereits existierenden Code zu optimieren. Primär für die Geschwindigkeit. Wie bereits erwähnt, kann es zu Verzögerungen bei dieser Version kommen.

\section{Externe Schnittstellen}
Da die \textit{libipc++} keine Abhängigkeiten von anderen Programmbibliotheken besitzt, gibt es als externe Schnittstelle nur die von \ac{os} angebotene \ac{api} für \ac{mpc} und \ac{ipc}. Eine Ausnahme stellt hier der Testingbereich dar. Dieser hat als Abhängigkeit das gTest Framework, gTest wird jedoch mit der Repo mitgeliefert um eine selbstständige Kompilierung samt Testing zu ermöglichen. Im Folgenden werden die Schnittstellen der \ac{os} \ac{api} kurz beschrieben.

\subsection{Win32}
\blindtext

\subsubsection{Multiprocessing}
\blindtext

\subsubsection{Pipes}
\blindtext

\subsubsection{Message Queues}
\blindtext

\subsubsection{Memory Mapped Files}
\blindtext

\subsubsection{Shared Memory}
\blindtext

\subsubsection{Semaphore}
\blindtext

\subsection{UNIX}
\blindtext

\section{Anforderungen an Performance}
\blindtext

\section{Qualitätsanforderungen}
\blindtext


\end{document}
